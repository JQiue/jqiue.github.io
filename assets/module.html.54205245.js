import{ac as t,A as p,B as o,z as a,M as n,H as c,E as i,ae as s,O as l}from"./framework.a879f165.js";const u={},d=s(`<p>早期的网站将所有代码全部写到一个文件，容易产生污染，JavaScript 最初的作用仅仅是验证表单，后来会添加一些动画，但是这些代码很多在一个文件中就可以完成了</p><p>随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等。<code>.js</code>文件逐渐多了起来，不再是一个文件就可以解决的了，而是把每一个文件当做一个模块，于是出现了这样的引入方式：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>jquery.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>jquery_scroller.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bar.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即简单的将所有的文件放在一起，优点是相比于使用一个文件，这种多个文件实现最简单的模块化的思想是进步的</p><p>缺点是因为每个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，也可以使用命名空间的方式来解决。对于大型项目，各种<code>.js</code>文件很多，必须手动解决模块和代码库的依赖关系，比如 jQuery 需要先引入，才能引入 jQuery 有关的插件。后期维护成本较高。还会导致依赖关系不明显，难以维护</p><p>随着前端的发展，JavaScript 不在局限于表单验证和特效制作上了，经过漫长的过程，JavaScript 终于暴露了自己先天就缺乏的一个功能：模块</p><p>虽然前端的 JavaScript 有着更多标准 API，但是对于后端的 JavaScript 来说，规范已经远远落后，有着以下很严重的缺陷：</p><ul><li>没有模块系统</li><li>标准库少，相对于前端来说</li><li>没有标准接口，没有 Web 服务器以及数据库之类的统一接口</li><li>缺乏包管理的能力，不能自动加载以及安装依赖</li></ul><p>对比其他语言来说，Java 有 import，Python 也有 import，Ruby 有 require 用来解决引入代码的机制。而 JavaScript 通过<code>&lt;script&gt;</code>引入代码的方式自然就显得混乱无比，自身根本就没有组织和约束能力，因此必须用命名空间等人为方式来约束代码</p><p>模块化能降低代码耦合度，功能模块直接不相互影响，根据定义，每个模块都是独立的，良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。维护一个独立的模块比起一团凌乱的代码来说要轻松很多</p><h2 id="非语言级别的模块化解决方案" tabindex="-1"><a class="header-anchor" href="#非语言级别的模块化解决方案" aria-hidden="true">#</a> 非语言级别的模块化解决方案</h2><ul><li>全局函数模式</li><li>命名空间（NameSpace）</li><li>IIFE 模式</li><li>增强的 IIFE 模式</li></ul><p>全局函数模式就是把功能封装成不同的全局函数，缺点是随着功能的增加，全局变量也多了起来</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Namespace 模式减少了全局变量，但本质是对象，外部可以直接修改，不安全</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">MODULE</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IIFE 模式将数据进行了私有化，外部只能通过暴露的方法操作，提高了安全性，缺点是不能和其他模块产生依赖关系</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">MODULE</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>
  <span class="token comment">// 封装私有化</span>
  <span class="token keyword">const</span> <span class="token function-variable function">setValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 封装私有化</span>
  <span class="token keyword">const</span> <span class="token function-variable function">getValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 向外暴露</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    setValue<span class="token punctuation">,</span>
    getValue
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>增强的 IIFE 模式解决了依赖关系，但是引入模块时必须有一定的先后顺序</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 模块一</span>
<span class="token keyword">const</span> module1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">show</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;module1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 模块二</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">globalThis<span class="token punctuation">,</span> module1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    module1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 给全局对象添加属性来实现暴露</span>
  globalThis<span class="token punctuation">.</span>module2 <span class="token operator">=</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>globalThis<span class="token punctuation">,</span> module1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="社区遵循的模块化规范" tabindex="-1"><a class="header-anchor" href="#社区遵循的模块化规范" aria-hidden="true">#</a> 社区遵循的模块化规范</h2><p>随着时间的发展，JavaScript 社区终于为其制定了相应的规范，其中 CommonJS 规范的提出是一个非常重要的里程碑，它为 JavaScript 提供了一个非常美好的前景，即在任何地方都能运行 JavaScript。JavaScript 不再停留在小脚本的阶段，而可以开发很多富客户端应用：</p><ul><li>服务端</li><li>命令行</li><li>桌面图形</li><li>混合应用</li></ul><p>当然不止 CommonJS，还有着其他的规范：</p><ul><li>AMD - 即 Asynchronous Module Definition，随着<code>require.js</code>的推广而产出</li><li>CMD - 即 Common Module Definition，由阿里玉伯提出，随着<code>sea.js</code>的推广而产出</li></ul><p>由于 Web 标准的推进直接导致 AMD 和 CMD 的过时，本篇并不会记录这两种规范的用法</p><h3 id="commonjs" tabindex="-1"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h3><p>CommonJS 是用在 Node.js 中的模块规范，Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，比较适用 Node.js</p><p>特点：</p><ul><li>方法，变量，属性，函数都是私有的，每个文件就是一个模块，有自己的作用域</li><li>同步加载，模块加载的顺序，按照其在代码中出现的顺序，浏览器端需要先对模块进行编译</li><li>只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载时就直接读取缓存结果</li><li>模块输出的是值的拷贝</li></ul><p>CommonJS 规范规定，每个模块内部都有两个 API：<code>module</code>和<code>require</code></p><p><code>module</code>变量代表当前模块，这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>

<span class="token comment">// 写法一</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">,</span>
  b
<span class="token punctuation">}</span>

<span class="token comment">// 写法二</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>

<span class="token comment">// 写法三</span>
exports<span class="token punctuation">.</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>

<span class="token comment">// 错误的写法：exports 是对 module.exports 的引用，不能直接给 exports 赋值</span>
exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">,</span>
  b
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>require</code>是一个方法，用于加载模块，本质是读取并执行一个 JavaScript 文件，返回该模块的 <code>exports</code>对象，如果模块输出的是一个函数，则要将函数定义在<code>module.exports</code>变量上，后缀名默认为<code>.js</code></p><ul><li>如果参数以&quot;/&quot;开头，则代表加载的是一个绝对路径的模块文件</li><li>如果参数以&quot;./&quot;开头，则代表加载的是一个相对路径的模块文件</li><li>如果参数字符串不带以&quot;./&quot;和&quot;/&quot;开头，则代表加载的是个默认提供的核心模块，比如位于各级的 node_modules 目录的已安装模块</li></ul>`,35),r={href:"http://browserify.org/",target:"_blank",rel:"noopener noreferrer"},k=s(`<h2 id="语言级别的模块化规范" tabindex="-1"><a class="header-anchor" href="#语言级别的模块化规范" aria-hidden="true">#</a> 语言级别的模块化规范</h2><p>随着 ES6 的到来，终于在语法层面上定义了模块化规范，成了浏览器和服务器端的通用模块解决方案，这直接导致 CommonJS、AMD、CMD 逐渐成为历史</p><p>特点：</p><ul><li>自动使用严格模式</li><li>静态加载</li><li>输出的是值的引用</li></ul><p>模块功能主要由两个命令构成：</p><ul><li><code>export</code> - 用于规定模块的对外接口</li><li><code>import</code> - 用于导入其他模块</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">let</span> foo<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> bar<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此外还有这种写法，和上面是等价的：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> foo<span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不能是这样的：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> foo<span class="token punctuation">;</span>
<span class="token keyword">let</span> bar<span class="token punctuation">;</span>

<span class="token comment">// 报错</span>
<span class="token keyword">export</span> foo<span class="token punctuation">;</span>
exprot bar<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立对应关系，上面的写法只是将一个值导出，而不是对外的接口</p><p>使用<code>export</code>命令定义了模块的接口后，就可以使用<code>import</code>加载了</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./xxx.js&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面改写接口，但是如果是个对象，改写属性是允许的</p><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> foo <span class="token operator">=</span> <span class="token string">&#39;baz&#39;</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变量<code>foo</code>的值在 500ms 后会变成<code>baz</code>，这和 CommonJS 不一样，CommonJS 导出的是一个完全新的拷贝</p><p>如果想要为导出的模块可以定义新名字，可以使用<code>exports default</code>，这样不再需要<code>import</code>中使用花括号来映射对应的接口</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// b.js</span>
<span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">&#39;b.js&#39;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个模块中只允许有一个<code>export default</code>，但是它可以和<code>export</code>混用，导入可以同时接受默认的接口以及映射的接口</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// b.js</span>
<span class="token keyword">import</span> foo<span class="token punctuation">,</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;a.js&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>ESM 中的顶层<code>this</code>指向<code>undefined</code></p></div><p><code>import</code>也具有提升效果，同时<code>import</code>和<code>export</code>只能在顶层中使用，不能再代码块中使用</p><p>但是<code>import</code>作为方法调用的时候可以在代码中使用，会返回一个 Promise 对象</p><h2 id="循环引用" tabindex="-1"><a class="header-anchor" href="#循环引用" aria-hidden="true">#</a> 循环引用</h2><p>模块之间互相导入就会产生循环引用问题</p>`,29),v=s(`<h2 id="兼容处理" tabindex="-1"><a class="header-anchor" href="#兼容处理" aria-hidden="true">#</a> 兼容处理</h2><p>因为大部分浏览器目前不支持 ES6 语法，所以需要 babel 和 browserify 来帮助编译</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> browserify <span class="token parameter variable">-g</span>
<span class="token function">npm</span> <span class="token function">install</span> babel-cli <span class="token parameter variable">-g</span>
<span class="token function">npm</span> <span class="token function">install</span> babel-preset-es2015 --save-dev
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 babel 时要在项目根目录创建一个<code>.babelrc</code>文件，用于 babel 运行时的控制</p><div class="language-JSON line-numbers-mode" data-ext="JSON"><pre class="language-JSON"><code>{
  &quot;presets&quot;: [&quot;es2015&quot;]
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>babel 被转换的文件/文件路径 <span class="token parameter variable">-d</span> 转换后的文件/文件路径
babel src <span class="token parameter variable">-d</span> build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 babel 可以将 ES6 语法转换成 ES5 语法，但是 ES5 语法还包括 CommonJS 语法，所以需要 browserify 继续转换</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>browserify build/main.js <span class="token parameter variable">-o</span> dist/index.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>`,10);function m(b,g){const e=l("ExternalLinkIcon");return p(),o("div",null,[d,a("p",null,[n("当然，在浏览器也是可以通过"),a("a",r,[n("browserify"),c(e)]),n("来实现，不同于服务端，它需要先编译打包处理")]),k,i(" to be updated "),v])}const f=t(u,[["render",m],["__file","module.html.vue"]]);export{f as default};
