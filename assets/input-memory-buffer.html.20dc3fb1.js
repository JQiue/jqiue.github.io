import{ac as n,A as s,B as a,ae as e}from"./framework.a879f165.js";const p={},t=e(`<h2 id="缓冲区" tabindex="-1"><a class="header-anchor" href="#缓冲区" aria-hidden="true">#</a> 缓冲区</h2><p>如果在用户输入一个字符后立即打印该字符就是属于无缓冲输入，但是对于一些需要按下特定按键（Enter）后才打印刚刚输入的字符属于缓冲输入，因为用户输入的字符被收集到了一个被称为缓冲区的临时储存区</p><p>缓冲区最重要的作用就是比逐个发送字符的无缓冲输入要更加节省时间，而且还可以修正打错的字符，保证最后是正确的输入</p><p>但是这并不能说无缓冲输入是没有用的，因为某些场景下期待按下某个键就立即作出反应的操作</p><p>缓冲分为：完全缓冲和行缓冲</p><p>完全缓冲指当缓冲区被填满时就刷新缓冲区，比如文件输入。而行缓冲则指在出现换行符时刷新缓冲区，比如键盘按下 Enter</p><p>先看一个例子</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\\n&quot;</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个程序中系统会接收两次数据，一般情况下，大部分人都是输入一次并回车然后继续输入</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">33</span> // 输入并回车
<span class="token number">33</span> // 打印
<span class="token number">55</span> // 输入并回车
<span class="token number">55</span> // 打印
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但实际上，可以这么输入</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">33</span> <span class="token number">55</span> // 用空格隔开两个数据并回车
<span class="token number">33</span> // 打印
<span class="token number">55</span> // 打印
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现，第二种输入方式等效于第一种方式，这和 scanf 函数的实现原理有关</p><p>scanf 函数会先从输入缓冲区中获取用户输入的数据，如果缓存区中没有数据，则会产生阻塞等待用户输入数据，如果用户输入了数据，scanf 函数则会将数据放入缓存区中，然后从缓存区中获取数据，如果缓存区中有了数据，则不会等待用户输入，会直接从缓存区中获取数据</p><p>这说明缓存区是会识别符号的，当识别到回车则代表这一次的输入结束，如果在两个数据之间识别了空格，则会将两个数据进行缓存，scanf 函数匹配缓存区中的数据类型，如果匹配则就获取出来赋值给相应变量</p><h2 id="清空缓存区" tabindex="-1"><a class="header-anchor" href="#清空缓存区" aria-hidden="true">#</a> 清空缓存区</h2><p>如果要求每次只输入一次数据，则需要清空缓存区，可以使用函数<code>fflush(stdin)</code>，这么做会让下一个 scanf 函数无法获得缓存区中的数据，也就可以等待用户输入了，但是这个函数只能在 windows 操作系统上使用，不适用于其他操作系统</p><p>而<code>setbuf(stdin, NULL)</code>是可以跨平台使用的，效果和<code>fflush(stdin)</code>一样</p><p>实际上，如果频繁使用 scanf 函数，则应该立即清空缓存区，避免影响后面的代码</p>`,19),c=[t];function o(i,u){return s(),a("div",null,c)}const d=n(p,[["render",o],["__file","input-memory-buffer.html.vue"]]);export{d as default};
