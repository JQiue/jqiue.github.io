const e=JSON.parse('{"key":"v-c557e330","path":"/js/proxy-reflect.html","title":"代理和反射","lang":"zh-CN","frontmatter":{"title":"代理和反射","category":["编程语言"],"tag":["JavaScript"],"article":false,"description":"Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 ES6 提供原生的 Proxy 构造函数，用来生成实例 ```js let proxy = new Proxy(target, handler); ``` Proxy 对象的所有用法，都是上面...","head":[["meta",{"property":"og:url","content":"https://jqiue.github.io/js/proxy-reflect.html"}],["meta",{"property":"og:site_name","content":"JQiue\'s notes"}],["meta",{"property":"og:title","content":"代理和反射"}],["meta",{"property":"og:description","content":"Proxy Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写 ES6 提供原生的 Proxy 构造函数，用来生成实例 ```js let proxy = new Proxy(target, handler); ``` Proxy 对象的所有用法，都是上面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-03-20T03:05:10.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"JavaScript"}],["meta",{"property":"article:modified_time","content":"2022-03-20T03:05:10.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"Proxy","slug":"proxy","link":"#proxy","children":[]},{"level":2,"title":"reflect","slug":"reflect","link":"#reflect","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1646459606000,"updatedTime":1647745510000,"contributors":[{"name":"JQiue","email":"861947542@qq.com","commits":2}]},"readingTime":{"minutes":3.78,"words":1133},"autoDesc":true,"localizedDate":"2022年3月5日","filePathRelative":"js/proxy-reflect.md"}');export{e as data};
